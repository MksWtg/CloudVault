trying to debug console hot reload:
i have a vue frontend and aspnet backend app. when i build aspnet as an exe using the csproj it serves backend at 7170 and frontend as static files it works. but when debugging backend at 7170 with visual studio debug and frontend at 5173 with npm run dev with hot reload, it does not connect the backend to frontend (getting 400 requests right now). The goal is to get npm run dev to work so i can make changes with hot reload. some extra information is i don't really care if we use http or https, you can see below what we currently use and and recommend a change if necessary. Also there is an authentication system in place, i think NTLM by default.

here is the csproj for the project so you can see the method that currently works:

```
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<UserSecretsId>4af2dfca-2284-4f3f-85f1-2e680260edcf</UserSecretsId>
	</PropertyGroup>

	<PropertyGroup Label="NLogConfiguration">
		<ProjectName>CargoWiseCloudConsole.WebApi</ProjectName>
		<ProjectBaseNamespace>CargoWiseCloudConsole</ProjectBaseNamespace>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AutoMapper" />
		<PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
		<PackageReference Include="Microsoft.Data.SqlClient" />
		<PackageReference Include="Microsoft.EntityFrameworkCore" />
		<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
		<PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" />
		<PackageReference Include="Microsoft.AspNetCore.Authentication.Negotiate" />
		<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
		<PackageReference Include="Microsoft.AspNetCore.OpenApi" />
		<PackageReference Include="Swashbuckle.AspNetCore" />
		<PackageReference Include="CargoWiseCloudNLog" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\Core\Core.csproj" />
		<UpToDateCheckInput Include="..\ConsoleFrontend\src\**\*" />
		<UpToDateCheckOutput Include="..\Bin\WebApi\wwwroot\**\*" />
	</ItemGroup>

	<Target Name="PostBuild" AfterTargets="PostBuildEvent">
		<Exec Command="cmd /c &quot;cd /d ..\ConsoleFrontend\  &amp;&amp; npm ci  &amp;&amp; npm run check-format  &amp;&amp; npm run build&quot;" Condition="$(ConfigurationName) == RELEASE" />
		<Exec Command="cmd /c &quot;cd /d ..\ConsoleFrontend\  &amp;&amp; npm install  &amp;&amp; npm run format  &amp;&amp; npm run build&quot;" Condition="$(ConfigurationName) == DEBUG" />
		<Exec Command="cmd /c &quot;robocopy ..\ConsoleFrontend\dist ..\Bin\WebApi\wwwroot /MIR &amp; IF %ERRORLEVEL% LSS 8 (exit 0) ELSE (exit %ERRORLEVEL%)&quot;" />
	</Target>

	<Target Name="PostRebuild" AfterTargets="Rebuild">
		<Exec Command="dotnet tool restore" />
		<Exec Command="dotnet tool run swagger tofile --output ..\..\Documentation\WebAPI\OpenAPI.json ..\Bin\WebApi\CargoWiseCloudConsole.WebApi.dll v1" />
		<Exec Command="cmd /c &quot;cd /d ..\ConsoleFrontend\  &amp;&amp; npm install  &amp;&amp; npm run documentation:generate&quot;" />
	</Target>

</Project>

```
  

  
Here is the ASPNET configuration file
```
using System.Net;
using System.Security.Claims;
using CargoWiseCloudConsole.Core.Common.Enums;
using CargoWiseCloudConsole.WebApi.Authorization;
using CargoWiseCloudConsole.WebApi.Middleware;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authentication.Negotiate;
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.AspNetCore.HttpLogging;
using Microsoft.IdentityModel.Tokens;

namespace CargoWiseCloudConsole.WebApi;

public static class WebApplicationConfiguration
{
	[System.Diagnostics.CodeAnalysis.SuppressMessage("Maintainability", "CA1506: Avoid excessive class coupling")]
	public static void ConfigureAndRun(this WebApplication webApplication)
	{
		ArgumentNullException.ThrowIfNull(webApplication);
		webApplication.UseHttpLogging();
		webApplication.UseMiddleware<RequestLoggingMiddleware>();

		if (webApplication.Environment.IsDevelopment())
		{
			webApplication.UseSwagger().UseSwaggerUI();
		}

		webApplication.UseStaticFiles();
		webApplication.UseDefaultFiles();
		webApplication.UseCors("Vue Frontend");
		webApplication
			.UseAuthentication()
			.UseAuthorization();

		var logger = webApplication.Services.GetRequiredService<ILogger<Program>>();
		webApplication.UseExceptionHandler(appError =>
		{
			appError.Run(async context =>
			{
				var contextFeature = context.Features.Get<IExceptionHandlerFeature>();
				context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
				context.Response.ContentType = "application/json";

				if (contextFeature != null)
				{
					logger.LogError(contextFeature.Error, "An unhandled exception has occured while executing the request");
					await context.Response.WriteAsync("Something went wrong. Please try again later");
				}
			});
		});

		webApplication.MapControllers();
		webApplication.MapFallbackToFile("index.html").AllowAnonymous();

		webApplication.Run();
	}

	public static WebApplicationBuilder ConfigureWebApplication(this WebApplicationBuilder webApplicationBuilder)
	{
		ArgumentNullException.ThrowIfNull(webApplicationBuilder);
		var configuration = webApplicationBuilder.Configuration;
		webApplicationBuilder.WebHost.ConfigureWebHost();
		webApplicationBuilder.Services
			.AddEndpointsApiExplorer()
			.AddSwaggerGen(options =>
			{
				options.CustomSchemaIds(type => type.FullName);
			})
			.ConfigureAuthentication(configuration)
			.ConfigureAuthorization()
			.ConfigureCors()
			.AddWindowsService()
			.AddHttpLogging(logging =>
			{
				logging.LoggingFields = HttpLoggingFields.RequestMethod
										| HttpLoggingFields.RequestPath
										| HttpLoggingFields.ResponseStatusCode
										| HttpLoggingFields.Duration;
				logging.CombineLogs = true;
			})
		;
		return webApplicationBuilder;
	}

	static void ConfigureWebHost(this IWebHostBuilder webHost)
	{
		webHost.UseKestrel(options =>
		{
			options.ListenAnyIP(7170);
		});
	}

	static IServiceCollection ConfigureAuthentication(this IServiceCollection services, ConfigurationManager configuration)
	{
		var authenticationMethod = configuration.GetValue<string>("AuthenticationMethod");
		if (authenticationMethod == nameof(AuthenticationType.NTLM))
		{
			services.AddAuthentication(NegotiateDefaults.AuthenticationScheme)
				.AddNegotiate();
			return services;
		}

		var tenantId = configuration.GetValue<string>("OIDCTenantId");
		var clientId = configuration.GetValue<string>("OIDCClientId");
		ArgumentNullException.ThrowIfNullOrEmpty(tenantId, nameof(tenantId));
		ArgumentNullException.ThrowIfNullOrEmpty(clientId, nameof(clientId));

		services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
			.AddJwtBearer(option =>
			{
				option.Authority = @$"https://login.microsoftonline.com/{tenantId}/v2.0";
				option.Audience = clientId;
				option.MapInboundClaims = false;
				option.TokenValidationParameters = new TokenValidationParameters
				{
					ValidateIssuer = true,
					ValidateAudience = true,
					ValidateLifetime = true,
					ValidateIssuerSigningKey = true,
				};

				option.Events = new JwtBearerEvents
				{
					OnTokenValidated = context =>
					{
						var nameClaim = context.Principal?.FindFirst("preferred_username");
						if (nameClaim != null && context.Principal?.Identity is ClaimsIdentity claimsIdentity)
						{
							claimsIdentity.AddClaim(new Claim(ClaimsIdentity.DefaultNameClaimType, nameClaim.Value));
						}
						return Task.CompletedTask;
					},
					OnAuthenticationFailed = context =>
					{
						var logger = context.HttpContext.RequestServices.GetRequiredService<ILogger<Program>>();
						logger.LogError(context.Exception, "Authentication failed.");
						return Task.CompletedTask;
					},
				};
			});
		return services;
	}

	static IServiceCollection ConfigureAuthorization(this IServiceCollection services)
	{
		return services.AddAuthorization(options =>
		{
			options.FallbackPolicy = options.DefaultPolicy;
			options.AddPolicy(Policies.RequireAdministrator, policy =>
				policy.Requirements.Add(new MinimumRoleRequirement(RoleName.Administrator)));
			options.AddPolicy(Policies.RequireOperatorOrHigher, policy =>
				policy.Requirements.Add(new MinimumRoleRequirement(RoleName.Operator)));
			options.AddPolicy(Policies.RequireViewerOrHigher, policy =>
				policy.Requirements.Add(new MinimumRoleRequirement(RoleName.Viewer)));
		});
	}

	static IServiceCollection ConfigureCors(this IServiceCollection services)
	{
		return services.AddCors(options =>
		{
			options.AddPolicy("Vue Frontend", builder =>
			{
				builder.WithOrigins("http://localhost:5173")
					.AllowAnyMethod()
					.AllowAnyHeader()
					.AllowCredentials();
			});
		});
	}
}

```
  
here is the vite config: 
```
import { fileURLToPath, URL } from 'node:url';

import { defineConfig } from 'vite';

import plugin from '@vitejs/plugin-vue';

import fs from 'fs';

import path from 'path';

import child_process from 'child_process';

import { env } from 'process';

  

/// <reference types="vitest" />

  

const baseFolder = env.APPDATA !== undefined && env.APPDATA !== '' ? `${env.APPDATA}/ASP.NET/https` : `${env.HOME}/.aspnet/https`;

  

const certificateName = 'test.client';

const certFilePath = path.join(baseFolder, `${certificateName}.pem`);

const keyFilePath = path.join(baseFolder, `${certificateName}.key`);

  

if (!fs.existsSync(certFilePath) || !fs.existsSync(keyFilePath)) {

    if (!fs.existsSync(baseFolder)) {

        fs.mkdirSync(baseFolder, { recursive: true });

    }

    if (

        0 !==

        child_process.spawnSync('dotnet', ['dev-certs', 'https', '--export-path', certFilePath, '--format', 'Pem', '--no-password'], { stdio: 'inherit' })

            .status

    ) {

        throw new Error('Could not create certificate.');

    }

}

  

const target = env.VITE_ASPNETCORE_HTTPS_PORT

    ? `http://localhost:${env.VITE_ASPNETCORE_HTTPS_PORT}`

    : env.VITE_ASPNETCORE_URLS

        ? env.VITE_ASPNETCORE_URLS.split(';')[0]

        : 'http://localhost:7170';

  

// https://vitejs.dev/config/

export default defineConfig({

    build: {

        target: 'es2022',

    },

    plugins: [plugin()],

    resolve: {

        alias: {

            '@': fileURLToPath(new URL('./src', import.meta.url)),

            '@common': path.resolve('./src/common'),

        },

    },

    server: {

        proxy: {

            '^/console': {

                target,

                secure: false,

            },

        },

        port: 5173,

        https: {

            key: fs.readFileSync(keyFilePath),

            cert: fs.readFileSync(certFilePath),

        },

    },

    test: {

        globals: true,

        environment: 'jsdom',

        coverage: {

            reporter: ['text', 'json-summary'],

            exclude: ['/node_modules/', '/tests/'],

        },

        include: ['**/*.{test,spec}.{js,ts}'],

    },

    css: {

        preprocessorOptions: {

            scss: {

                api: 'modern-compiler',

            },

        },

    },

});
```
  
here is env:  
`VITE_ASPNETCORE_HTTPS_PORT = 7170 VITE_ASPNETCORE_URLS = http://localhost:7170` 

when i visit the page, the base page frame loads. then to load content, it makes a request to https://localhost:5173/security/authorized-apis which returns 200, but instead of hitting the backend it just returns frontend xml.

RESPONSE:
```
<!doctype html>
<html lang="en">
	<head>
		<script type="module" src="/@vite/client"></script>

		<meta charset="UTF-8" />
		<link rel="icon" href="/src/assets/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>CargoWise Cloud Console</title>
	</head>
	<body>
		<div id="app"></div>
		<script type="module" src="/src/main.js"></script>
	</body>
</html>
```
  
help debug and fix. please give clear instructions.